/**
 * @name es5
 * 书籍链接 http://crockford.com/javascript/
 * 
 * 
 * 
 * js是轻量级的脚本语言
 * 不具备开发操作系统的能力
 * js也是嵌入式语言 核心语法不多
 * js本身不提供任何 I/O 输入/输出 input/output 相关的api要考宿主环境提供
 * 所以js只适合嵌入更大型的应用程序环境，去调用宿主环境提供的底层api
 * 嵌入js的宿主环境有多种 最常见的环境就是浏览器
 * 另外还有服务器环境 也就是node项目
 * 
 * 从语法角度看 js语言是一种“对象模型”语言  各种宿主环境通过这个模型，描述自己的
 * 功能和操作接口 从而通过js控制这些功能
 * js不是纯粹的 面向对象语言 还支持其他编程范式 比如函数式编程
 * 这导致几乎任何一个问题 js都有多种解决方法 js高度灵活
 * 
 * js的核心语法相当精简 包括两个部分 基本的语法构造（比如操作符 控制结构 语句）
 * 和标准库（就是一系列具有各种功能的对象 比如 Array Date Math） 
 * 除此以外，各种宿主环境提供额外的api 即只能在改环境使用的接口
 * 以便js调用 
 * 以浏览器为例，它提供的额外api可以分成三大类
 * 1 浏览器控制类 操作浏览器
 * 2 DOM类 操作网页的各种元素
 * 3 Web类 实现互联网的各种功能
 * 
 * 如果宿主环境是服务器 如node 则会提供各种操作系统的api 比如文件操作api
 * 网络通信api 这些你都可以在node环境中找到
 * 
 * 本书主要介绍js核心语法和浏览器网页开发的基本知识 不涉及node
 * 只要分成四大部分
 * 1 基本语法
 * 2 标准库
 * 3 浏览器 api 
 * 4 dom
 * 
 * js有一些显著特点 值得学习 
 * 
 * js发明的目的 就是作为浏览器的内置脚本语言 为网页开发者提供操作浏览器
 * 的能力 所有浏览器都支持
 * 
 * js慢慢超越了浏览器 正在向通用的系统语言发展
 * 
 * 1 h5的出现 浏览器的功能越来越强 平台化
 * 
 * 2 node
 * 
 * 3 数据库操作
 * 
 * 4 移动平台开发
 * react native 项目则是将js写的组件编译成原生 从而使他们具有优秀的性能
 * 
 * 5 内嵌脚本语言
 * 
 * 6 跨平台的桌面应用程序
 * 
 * 7 
 * 
 * 
 * 易学性
 * 学习环境无处不在
 * 简单性
 * 与主流语言相似性
 * 
 * 
 * 
 * */ 


/**
 * @name 历史
 * 
 * 万维网 只能在操作系统的终端浏览
 * mosaic 第一个浏览器
 * 
 * 基本语法 借鉴c语言和java
 * 数据结构 借鉴java 将值分为原始值和对象两大类
 * 函数用法 引入闭包
 * 原型继承
 * 正则表达
 * 字符串和数组处理 
 * 
 * 从一开始就注定 js的编程风格是函数式编程和面向对象编程的一种混合体
 * 
 * 网页应用时候状态机
 * 
 * 
 * 
 * */ 


/**
 * @name 基本语法
 * 
 * 1 语句 js程序执行单位为行
 * 
 * 语句 是为了完成某种任务而进行的操作 赋值语句
 * 
 * 表达式 得到返回值的计算式 
 * 
 * 赋值语句的等号右边 预期是一个值 可以放置各种表达式 函数表达式
 * 
 * 2 变量 
 * js 变量名区分大小写 
 * 
 * 2.2变量提升
 * js的工作方式是 先解析代码 获取所有被声明的变量 ，然后再一行一行的运行
 * 这造成的结果 就是所有的变量的声明语句 都会被提升到代码头部
 * 这就叫做变量提升
 * 
 *  标识符 js的一些保留字 不能做标识符
 * 
 * 区块 
 * js使用大括号 将多个相关的语句结合在一起 称为区块block
 * 
 * 对于var js不构成单独作用域
 * 
 * 区块往往用来构成其他更复杂的语法结构 
 * 
 * 
 * 
 * */ 

/**
 * 数据类型
 * null undefine 布尔值
 * 数值
 * 字符串
 * 对象
 * 函数
 * 数组
 * 
 * 
 * 函数是一段可以反复调用的代码块
 * 函数还能几首输入的参数
 * 不同的函数会返回不同的值
 * 
 * js有三种声明函数的方法
 * 1 function命令
 * 2 函数表达式
 * 3 function构造函数
 * 
 * 函数的重复声明
 * 后面的声明会覆盖前面的声明
 * 
 * 调用函数时 要使用圆括号运算符
 * 圆括号之中 可以加入函数的参数
 * 
 * return语句所带的那个表达式 就是函数的返回值
 * 
 * return语句不是必需的 
 * 
 * 函数可以自己调用自己 这就是递归
 * 
 * 下面就是通过递归 计算斐波那契的数列
 * 
 * function fib(num){
 *   if(num===0) return 0;
 *   if(num===1) return 1;
 *   return fib(num-2)+fib(num-1)
 * }
 * 
 * fib(6)   8
 * 
 * js 语言将函数看做一种值 与其他值地位相等 函数只是一个可以执行的值 此外
 * 并无特殊之处
 * 
 * 函数为第一等公民
 * 
 * 函数名的提升
 * 
 * 函数的属性和方法
 * 函数的name属性返回函数的名字
 * 
 * 函数的length属性返回函数预期传入的参数个数
 * 
 * js只有两种作用域 变量在整个程序中一直存在
 * es6又新增块级作用域
 * 
 * 函数内部定义的变量 会在改函数作用域内覆盖全局变量
 * 
 * 函数运行的时候 有时候需要提供外部数据
 * 不同的外部数据会得到不同的结果 这种外部数据就是参数
 * 
 * 函数参数不是必需的 js允许省略参数
 * 
 * 函数参数如果是原始类型的值 传递方式是传值传递 这意味着
 * 在函数体内修改参数值 不会影响到函数外部
 * 
 * arguments对象
 * 
 * 需要一种机制 可以在函数内部读取所有的参数
 * 
 * agruments 对象带有一个callee属性
 * 返回它所对应的原函数
 * 
 * 
 * 闭包
 * 是js语言的难点 也是它的特色 很多高级应用都要依靠闭包实现
 * 
 * 理解闭包 首先必须理解变量作用域
 * js有两种作用域 
 * 
 * 就是在函数内部 再定义一个函数
 * 
 * f1内部的所有局部变量 对f2都是可见的 
 * 这就是js语言特有的链式作用域
 * 子对象会一级一级的向上寻找父对象的变量 所以
 * 父对象的所有变量 对子对象都是可见的 反之则成立
 * 
 * 上面代码中 函数f1的返回值就是函数f2
 * 由于f2可以读取f1的内部变量 所以就可以在
 * 外部获取f1的内部变量了
 * 
 * 可以把闭包简单理解成定义在一个函数内部的函数
 * 
 * 闭包最大的特点就是它可以记住 诞生环境 
 * 本质上 闭包就是将函数内部和外部连接起来的桥梁
 * 
 * 闭包最大的两个用处 
 * 
 * 一个是可以读取函数内部的变量 另一个就是让这些变量
 * 始终保存在内存中、
 * 
 * 闭包的另一个用处就是 封装对象的私有属性和私有方法
 * 
 * 立即调用函数表达式
 * 
 * eval 命令
 * 
 * eval命令接受一个字符串作为参数 并将真个字符串 当做语句执行
 * 
 * 
 * 
 * 
 * @name 对象
 * 对象是js语言的核心概念 也是最重要的数据类型
 * 
 * 简单说 对象就是一组键值对的集合
 * 是一种无序的复合数据集合
 * 
 * 对象的所有键名都是字符串
 * 
 * 如果不同的变量名指向同一个对象 那么他们都是这个对象的引用
 * 
 * 赋值是浅拷贝
 * 
 * 读取对象的属性 一种是使用点运算符 还有一种是使用方括号运算符
 * 
 * 查看一个对象本身所有的属性 可以使用 Object.keys()方法
 * 
 * delete 命令用于删除对象的属性 删除成功后返回true
 * 
 * 属性是否存在
 * in 运算符
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * */ 


// function f1(){
//   var n=999;
//   function f2(){
//     console.log(n);
//   }

//   return f2;
// }

// var result = f1();
// console.log(f1()());



/**
 * @name 算数运算符
 * 
 * js共提供10个算数运算符 来完成基本的算数运算
 * 
 * 加法运算符 x+y 
 * 减法运算符 x-y
 * 乘法  *
 * 除法  /
 * 指数 **
 * 余数 %
 * 自增 ++x x++
 * 自减 --x x--
 * 数值运算符 +x
 * 负数值运算符+x
 * 
 * 
 * js允许非数值的相加
 * 
 * 余数运算符 返回前一个运算子被后一个运算子除 所得的余数
 * 
 * 
 * 布尔运算符
 * 四个运算符
 * 取反 ！
 * 且运算 &&
 * 或运算 ||
 * 三元
 * 
 * 二进制位运算符
 * 
 * 
 * 
 * 
 * */ 


/**
 * @name 语法专题
 * 
 * 强制转换
 * Number() String() Boolean()
 * 
 * js原生提供Error构造函数
 * 
 * 
 * 
 * 
 * 
 * */  



/**
 * @name 浏览器模型
 * 
 * js是浏览器的内置脚本 也就是说 浏览器内置了js引擎 并且提供各种接口
 * 
 * 让js脚本可以控制浏览器的各种功能
 * 
 * script元素内部可以直接写js代码
 * 
 * type属性可以设为两种值 text/jajascript
 *                      application/javascript
 * 
 * script标签页可以指定加载外部的脚本文件 
 * 如果脚本文件使用了非英语字符 还应注明字符的编码
 * 
 * 网页元素的事件属性 可以写入js代码 可以写入js代码 
 * 
 * url协议 url支持js协议 即在url的位置写入代码 使用这个url的时候就会执行js代码
 * 
 * script元素
 * 浏览器加载js脚本 主要通过script元素完成 
 * 
 * 浏览器一边下载html网页 一边开始解析
 * 解析过程中 浏览器发现script元素 就暂停解析 把网页渲染的控制权交给js引擎
 * 如果给script元素引用了外部脚本 就下载该脚本再执行 否则就直接执行代码
 * 
 * js引擎执行完毕 控制权交还渲染引擎 恢复往下解析html网页
 * 
 * 如果外部脚本加载时间很长 那么浏览器就会一直等待脚本下载完成 
 * 造成网页长时间失去响应 浏览器就会呈现 假死 状态 这被称为阻塞效应
 * 
 * 为了解决脚本文件下载阻塞网页渲染的问题 对script元素加入defer属性 
 * 
 * 解决阻塞效应的另一个方法是对script元素加入async属性
 * 
 * 脚本的动态加载
 * script元素可以动态生成 生成后再插入页面 从而实现脚本的动态加载
 * 
 * 浏览器的核心是两个部分 渲染引擎和js解释器 又称js引擎
 * 
 * firefox Gecko 引擎
 * safari webkit引擎
 * chrome blink 引擎
 * ie trident 引擎
 * edge edgeHTML引擎
 * 
 * js引擎 
 * js引擎的主要作用 读取网页的js代码 对其处理后运行
 * js是一种解释型语言 
 * 
 * 
 * window对象
 * 指当前的浏览器窗口
 * 
 * window.name属性是一个字符串 表示当前浏览器窗口的名字 
 * 
 * 只要浏览器窗口不关闭 这个属性是不会消失的 
 * 
 * window.closed window.opener
 * 
 * window.self window.window 属性都指向窗口本身 这两个属性只读
 * 
 * window.frameElement 
 * 
 * window.top  window.parent
 * 
 * window.status 属性用于读取浏览器状态栏的文本
 *  
 * window.screenX 和 window.screenY 返回浏览器窗口左上角相对于当前屏幕
 * 左上角的水平距离和垂直距离 这两个属性只读
 * 
 * innerHeight innerWidth
 * 
 * 
 * 
 * @name window对象的方法
 * window.alert() window.prompt() window.confirm() 都是浏览器于用户
 * 互动的全局方法
 * 
 * window \n可以换行
 * 
 * 
 * @name navigator对象的属性
 * navigator.uerAgent
 * 
 * 识别浏览器不是一个好办法 因为必须考虑 所有的情况 非常麻烦 而且用户可以改变这个
 * 字符串 
 * 
 * var ua=navigator.userAgent.toLowercase();
 * 
 * 
 * if(/mobi/i.tset(ua)){
 *   手机浏览器
 * } else{
 *   非手机浏览器
 * }
 * 
 * navigator.plugins
 * 返回 浏览器安装的插件
 * 
 * navigator.platform
 * 返回用户的操作系统信息
 * 
 * 
 * @name Cookie
 * 
 * Cookie是服务器保存在浏览器的一小段文本信息 
 * 每个cookie的大小一般不能超过4k 
 * 
 * 常用场合有以下一些
 * 
 * 对话session 管理 保存登录 购物车 等需要的记录信息
 * 个性化 保存用户的偏好 比如网页字体大小 背景色 
 * 追踪 记录和分析用户行为
 * 
 * cookie容量很小 缺乏数据操作接口 客户端存储应该使用web storage API
 * 和IndexedDB
 * 
 * cookie包含以下几个方面的信息
 * Cookie 的名字
 * Cookie 的值
 * 到期时间 所属域名 生效的路径
 * 
 * 浏览器可以设置不接受 Cookie 也可以设置不向服务器发送Cookie
 * 
 * window.navigator.cookieEnabled 
 * 
 * Cookie 由 HTTP 协议生成 也主要供Http协议使用
 * 
 * HTTP请求 Cookie的发送
 * 浏览器向服务器发送http请求时 每个请求都会带上相应的cookie 
 * 也就是说 把服务器早前保存在浏览器的这段信息 再发回服务器
 * 
 * 
 * Cookie的属性
 * Expires属性指定一个具体的到期时间 到了指定时间以后 浏览器就不在保留这个COOKIE
 * 
 * 浏览器根据本地时间 决定cookie是否过期
 * 
 * domain path
 * 
 * 
 * @name XHLHttpRequest对象
 * 
 * XHRHttpRequest 对象是ajax的主要接口 用于浏览器和服务器
 * 之间的通信
 * XMLHttpRequest 对象本身是一个构造函数 可以使用new命令生成实例
 * 他没有任何参数
 * 
 * XHR 
 * 
 * 
 * @name CORS
 * 
 * 
 * 
 * */ 


// console.log(navigator.userAgent);

// console.log(navigator.plugins);

// console.log(navigator.platform)

